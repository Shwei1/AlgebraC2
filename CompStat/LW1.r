########################################################
# Завдання №1
########################################################

# print(<обʼєкт>) - функція для виводу аргументу в консоль

print(0.135)

# str(<обʼєкт>) - показує внутрішню структуру будь-якого обʼєкту.

str(c(1, 2, 3, 4, 5, 6, 7, 10))

# c(<обʼєкт1>, <обʼєкт2>, ..., <обʼєкт_n>)

c(1, 2, 3, 4, 5, 6, 7, 10)

# seq(<початок>, <кінець>, <крок>) - створює вектор з арифметичної прогресією із заданим кроком.

seq(0, 10, 0.5)

# rep(<значення>, <кількість>) - повертає вектор, де задане значення повторюється задану кількість разів.

rep(1, 100)

# numeric(<довжина>) - створює числовий вектор (автоматичне заповнює нулями).

numeric(26)

# names(<вектор>) - повертає назви елементів вектора.

price_vector <- c("apple" = 5, "pear" = 10, "cherry" = 15)

names(price_vector)

# rbind(<вектор1>, <вектор2>, ..., <вектор_n>) - обʼєднує надані вектори-рядки в матрицю.

rbind(1:3, 4:6)

# cbind(<вектор1>, <вектор2>, ..., <вектор_n>) - обʼєднує надані вектори-стовпчики в матрицю.

cbind(1:3, 4:6)

# matrix(<вектор>) - повертає матрицю, що заповнюється значеннями з наданого вектору.
# Приймає параметри nrow=n та ncol=m для визначення кількості рядків та стовпців відповідно.

matrix(1:10, nrow=2, ncol=3)

# dimnames(<матриця>) - повертає назви рядків і стовпців матриці.

M = matrix(1:4, nrow=2, ncol=2)
dimnames(M) <- list(c("bi", "bo"), c("bi", "bo"))

# rownames(<матриця>) - повертає назви рядків.

rownames(M)

# colnames(<матриця>) - повертає назви стовпців.

colnames(M)

# diag(<вектор>) або diag(<матриця>) - якщо аргументом є матриця, то повертає
# її діагональ у вигляді вектору. Якщо вектор, то повертає діагональну
# матрицю.

diag(M)
diag(3:5)

# solve(<матриця> A, <вектор> b) - вирішує рівняння Ax=b, повертає вектор розвʼязків. Якщо аргументом буде лише матриця, то функція поверне її обернену матрицю. 

x <- c(1, 2)

solve(M, x)

# min(<масив>), max(<масив>) - повертають мінімальне та максимальне значення з масиву відповідно.

x <- 1:10
min(x)
max(c(324, 32, 43, 999, 87))

# sum(<масив>) - повертає суму елементів масиву.

sum(1:10)

# length(<масив>) - повертає кількість елементів масиву.

length(x)

# t(<матриця>) - транспонує задану матрицю

t(M)

# order(<масив>) - повертає масив індексів (з одиниці), за якими елементи розташовані
# в порядку зростання.

x <- c(7, 1, 5, 10, 8)
order(x)

# [1] 2 3 1 5 4
# Тобто у відсортованому масиві на першому місці стояв би другий елемент
# початкового масиву, на 2-му 3-ій і т.д.

# sort(<масив>) - повертає відсортований (за замовчуванням, у порядку зростання) масив. 

sort(x)

########################################################
# Завдання №2
########################################################

remove_top_bottom <- function(arr, alpha=0.05){
    n <- length(arr)
    bound <- floor(n*alpha / 2)

    # Отримуємо масив індексів у порядку зростання відповідних елементів.
    # Видаляємо bound найменших елементів за їх індексами.
    indices <- order(arr)
    arr <- arr[-indices[1:bound]]

    # Маємо вже інший масив, тож перераховуємо знову його довжину та порядок.
    # Забираємо з нього найбільші елементи за їх індексами.
    n <- length(arr)
    indices <- order(arr)
    arr <- arr[-indices[(n-bound+1):n]]

    return(arr)
}

v <- c(4, 18, 19, 11, 15, 1, 10, 12, 17, 14, 16, 9, 13, 5, 2, 8, 7, 3, 20, 6)

print(remove_top_bottom(v, 0.2))

########################################################
# Завдання №3
########################################################

PulpFiction <- list(
        Title = "Pulp Fiction",
        Director = "Quentin Tarantino",
        Type = "Film",
        Genre = "Crime",
        Year = 1994,
        Duration = 154,
        Characters = data.frame(
            Name = c("Vincent Vega", "Jules Winnfield", "Mia Wallace", 
            "Winston Wolfe", "Marsellus Wallace"),
            Actor = c("John Travolta", "Samuel L. Jackson", "Uma Thurman", "Harvey Keitel", "Ving Rhames"),
            Survived = c(FALSE, TRUE, TRUE, TRUE, TRUE),
            Good = c(FALSE, FALSE, FALSE, FALSE, FALSE)
        )
)

print(PulpFiction)

########################################################
# Завдання №4
########################################################

stats <- function(x){
    arr <- numeric(10)
    arr[1] <- mean(x)
    arr[2] <- exp(mean(log(x)))
    arr[3] <- length(x)/sum(1/x)
    arr[4] <- median(x)
    arr[5] <- var(x)
    arr[6] <- sd(x)
    arr[7] <- mad(x)
    arr[8] <- mean(abs(x-mean(x)))
    arr[9] <- IQR(x)
    arr[10] <- diff(range(x))
        
    names(arr) <- c("Mean", "GM", "HM", "Med", "SV", "SD", "MAD", "MADm", "IQR", "Range")
    return(arr)
}

stats(c(6.7, 3.4, 0.8))

########################################################
# Завдання №5
########################################################

harmonic_series <- function(alpha, delta=1e-6, m=10000){

    if (alpha >= -1){
        stop("Порушені умови збіжності ряду.")
    }
    
    iter <- 1
    prev_sum <- 0
    result <- 0

    # Починаємо цикл. В R-і немає циклу do-while, тому окремо забезпечимо
    # першу ітерацію.
    while((iter == 1) || (abs(result - prev_sum) >= delta)){
        if (iter > m){
            stop("Перевищена кількість допустимих ітерацій.")
        }

        prev_sum <- result 
        result <- result + iter ^ alpha     
        iter <- iter + 1
    }

    print(result)
}

harmonic_series(-2, 1e-8)
